workflow:
    name: Spring Boot Gradle Pipeline  # Nom personnalisé du pipeline
    rules:
        - if: $CI_COMMIT_BRANCH == 'main' || $CI_COMMIT_BRANCH =~ /^gradle/
          when: always
        - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^gradle/ && $CI_PIPELINE_SOURCE == 'merge_request_event'
          when: always


stages:
  - test
  - sast
  - build


variables:
  # Database configuration
  SPRING_DATASOURCE_URL: "jdbc:mysql://mysql:3306/ytlecture?createDatabaseIfNotExist=true"
  SPRING_DATASOURCE_USERNAME: "root"
  SPRING_DATASOURCE_PASSWORD: "root"

  # Gradle configuration
  GRADLE_OPTS: "-Dorg.gradle.daemon=false -Dorg.gradle.caching=true"

  # SonarQube configuration
  SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Définit l'emplacement du cache des tâches d'analyse
  GIT_DEPTH: "0"  # Indique à git de récupérer toutes les branches du projet, requises par la tâche d'analyse
  SONAR_HOST_URL: "$SONAR_HOST_URL"  # Assurez-vous que cette variable est définie dans les settings CI/CD
  SONAR_TOKEN: "$SONAR_TOKEN"  # Assurez-vous que cette variable est protégée dans les settings CI/CD


cache:
  key: "${CI_COMMIT_REF_SLUG}-gradle"  # Cache spécifique à la branche pour éviter les conflits
  paths:
    - .gradle/wrapper
    - .gradle/caches
    - build/libs
    - .sonar/cache  


services:
  - name: mysql:8.0
    alias: mysql
    variables:
      MYSQL_ROOT_PASSWORD: "root"
      MYSQL_DATABASE: "ytlecture"


.test-setup: &test-setup
  before_script:
    - apt-get update -yq && apt-get install -y mysql-client  # Installation du client MySQL
    - echo "Waiting for MySQL to be ready..."
    - until mysqladmin ping -hmysql --silent; do sleep 2; done


# Job de test
test-java-project:
  stage: test
  image: gradle:8.4-jdk21
  <<: *test-setup
  script:
    - gradle test --no-daemon
  artifacts:
    reports:
      junit: build/test-results/test/TEST-*.xml
    paths:
      - build/reports/
      - build/test-results/
    expire_in: 1 week
    when: always
  allow_failure: false     # Permet au pipeline de s'arrêter si les tests échouent


# Job pour l'analyse SAST avec SonarQube
sonarqube-check:
  stage: sast
  image: gradle:8.4-jdk21
  needs: ["test-java-project"]  # Dépendance pour récupérer les rapports de tests
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - gradle sonarqube 
      -Dsonar.projectKey="Spring_Boot_Project" 
      -Dsonar.projectName="Spring Boot Project"
      -Dsonar.java.binaries=build/classes 
      -Dsonar.tests=src/test/java 
      -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml 
      -Dsonar.host.url=${SONAR_HOST_URL} 
      -Dsonar.token=${SONAR_TOKEN} 
      -Dsonar.qualitygate.wait=true 
      --no-daemon
  allow_failure: false


# Job de build
build-java-project:
  stage: build
  image: gradle:8.4-jdk21
  script:
    - gradle clean build -x test --no-daemon
  artifacts:
    paths:
      - build/libs/*.jar   # Conserver le JAR généré
    expire_in: 1 hour
  only:
    - main
    - /^gradle.*$/  